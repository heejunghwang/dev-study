프로세스 관리

1. 프로세스의 개념 및 상태

(1) 프로세스의 개념

* 많은 프로그램을 실행할 경우 프로세스 관리가 필요함
* 프로세스
  - 메모리에 적재된 프로그램, 현재 실행되고 있는 프로그램
  - 자원들이 할당되어 수행 가능한 상태에 있는 프로그램 : 프로그램 실행을 위해 CPU, 메모리 파일, 입출력 장치 등과 같은 시스템 자원들을 필요
  - 프로그램 파일 자체가 아닌 파일 시스템에서 메모리로 호출된 하나이 복사본
  - 살아 있는 동안 많은 시스템 자원을 사용 : 명령 수행을 위해 CPU를, 명령어와 데이터 저장을 위해 물리적 메모리 사용
  - 파일 시스템의 파일들을 열고 사용할 수도 있고, 시스템 내의 물리적인 장치들을 직, 간접으로 사용할 수도 있음
* 운영체제
  - 하나의 프로세스가 시스템의 물리적 메모리나 CPU의 대부분을 독점하지 않게 하기 위해 프로세스 자산과 프로세스가 가지고 잇는 시스템 자원에 대해서 계속 추적하고 있어야함

(2) 프로세스의 상태
  1) 준비
     - 외부 장치들로 부터의 I/O가 종료되기를 기다리거나, 프로세스가 CPU를 사용하고 있지는 않지만 언제든지 사용할 수 있도록 준비된 상태
     - 대부분의 프로세스가 여기에 해당
     - CPU가 한번에 하나의 프로세스 밖에 실행 시킬 수 없기 때문에 아직 CPU를 할당 받지 못한 프로세스들은 Ready 상태로 시스템의 큐(Queue)에 등록되어 CPU의 할당을 기다림
  2) 실행
     - 프로세스가 CPU를 차지하여 현재 실행 중인 상태	  
     - 종료 : 프로세스가 완전히 수행을 종료한 상태, 프로세스가 종료되면 운영체제에 의해 시스템에서 제거
 3) 대기
    - 프로세스가 어떠한 사건(event)를 기다리는 상태 (CPU를 할당받도록 대기 중인 상태 아님!)
    - 예) 외부 장치들로부터의 I/O가 종료되기를 기다리거나, 한 프로세스가 종료되기를 기다리거나 어떤 자원이 사용 가능해지기를 기다리는 경우
* 프로세스의 상태
~~~
        준비<--------디스패치---- 실행 ----입출력요청(블록)-----> 대기----웨이크업---------> 준비
          -----타이머런아웃--->
~~~

* 프로세스 상태의 전이 : 프로세스가 생성되어 종료될 때까지 준비, 실행, 대기 상태를 반복하며 실행
  - 준비에서 실행으로 전이되는 타이머 런아웃 과정이 있는데 이는 준비 상태에 있던 프로세스 중에서 가장 우선 순위가 높은 프로세스가 cPU를 취하여 실행 상태로 바뀌는 것을 말함
* 반대로 실행 상태에서 준비 상태로 전이되는 경우, 디스패치라 함
  - 특정 프로세스가 CPU를 독점하는 것을 방지하기 위한 것으로 주어진 시간 내 작업이 끝나지 않으면 운영체제가 CPU의 사용을 해당 프로세스로부터 강제로 회수하여 이때 실행 상태에서 준비 상태로 전이
* 실행 상태에서 대기 상태로 변경되는 경우가 있는 이를 블록이라고 함
  - 실행 상태의 프로세스가 규정된 시간 이전에 입출력 요구와 같은 수행을 요구하는 경우 스스로 CPU를 다른 프로세스에게 양보를 하고 대기 상태로 전이
* 대기 상태에서 준비 상태로 전이하는 경우 웨이크업이라고 함
  - 대기 상태에 있던 프로세스가 입출력이 완료됨에 따라 CPU의 제어를 얻기 위해 준비 상태로 전이 하는 것
* 문맥교환
  - 어떤 프로세스가 CPU를 다른 프로세스에게 넘겨줄 때, 현 프로세스의 정보들이 레지스터에서 삭제되어야 하고, 새로 수행될 프로세스의 정보들이 레지스터에 저장되어야 하는데 이 작업을 문맥교환이라함
* 프로세스 제어 블록(PCB : Process Control Block)
    - 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓은 장소
    - 운영체제가 CPU의 제어를 다른 프로세스에게 넘겨줄 떄, 현재 실행 중인 프로세스의 정보를 해당 PCB에 저장한 후 제어를 넘겨줌
    - 제어가 다시 이전 프로세스에게 넘겨질 떄 운영체제는 PCB에 있는 정보를 이용하여 실행
    - PCB는 프로세스 생성 시 만들어지며, 모든 프로세스는 각각 고유한 PCB를 가짐, 프로세스의 수행이 완료되면 해당 PCB도 함께 삭제되며 PCB의 내용은 프로세스의 상태 변화가 일어난 후 변경
      1) 프로세스 상태 : 실행(Running), 준비(Ready), 대기(Waiting), 완료(Terminated) 등의 프로세스 상태를 말함
      2) 프로그램 카운터
       - 프로세스 수행을 위한 다음 명령의 주소를 표시
       - 프로그램 카운터와 함께 프로세스 상태 정보는 인터럽트 발생시 저장되어야 하는데, 이것은 후에 프로세스의 정확한 수행을 계속하기 위함
      3) 레지스터
      - 컴퓨터 구조에 따라 다양한 형식과 구조를 가짐
      - 누산기, 인덱스 레지스터 그리고 범용 레지스터 등이 있음
       4) 회계 및 입출력 상태 정보
       - CPU 사용기간, 실제 사용 기간, 시간 제한, 작업이나 프로세스 번호 등을 포함하는 회계 정보와 특별한 입출력 요구
       - 이 프로세스에 할당된 입출력 장치 등을 포함하는 입출력 상태 정보를 말함
       5) CPU 스케줄링 정보
       - 프로세스의 우선순위, 스케쥴링 큐에 대한 포인터, 그리고 다른 스케줄링 매게 변수들을 포함	  
* 프로세스의 생성
   - 부모 프로세스 : 다른 프로세스를 생성
   - 자식 프로세스 : 생성된 새로운 프로세스
   - 부모 프로세스는 그 자식 프로세스와 병행적으로 실행을 계속할 수도 있고, 또한 자식 프로세스들이 종료될 때까지 기다릴 수도 있음
   - 일반적으로 프로세스는 작업을 수행하기 위해 중앙처리 장치, 기억장치, 파일, 입출력 장치 등의 자원들이 필요
   - 자식 프로세스를 생성시키면 생성된 자식 프로세스는 운영체제로부터 직접 자원을 얻거나 부모 프로세스의 자원을 이부부능ㄹ 얻음
* 자원 공유
   - 부모 프로세스는 자식 프로세스에게 자원을 나누어 주거나 공유할 수 있도록 함
   - 자식 프로세스의 자원을 부모 프로세스의 자원으로 제한하는 이유는 너무 많은 자식 프로세서를 생성하는 것으로 인하여 시스템이 과부하가 걸리는 것을 예방
   - 한 프로세스가 생성되었을 때 물리적, 논리적 자원을 얻는 것 욍도 몇몇 초기화 데이터(입력)가 부모 프로세스에 의해 자식 프로세스로 전달
   - 부모 프로세스는 자신의 자식 프로세스들의 식별자를 알고 있어야함
   - 한 프로세스가 새로운 프로세스를 생성할 떄, 새롭게 생성되는 프로세스의 식별자는 부모 프로세스에게 전달되어야함
 * 일반적으로 하나의 프로세스는 마지막 문장이 실행을 마쳤을 때 종료되며, 이 때 프로세스는 부모 프로세스에게 실행 결과를 되돌려줌
 * 부모 프로세스는 다음의 이유 때문에 자식 프로세스들의 실행을 종료 시킬 수 있음
     1) 자식 프로세스가 할당된 자원의 사용을 초과할 때
     2) 자식 프로세스에게 할당된 작업이 더 이상 필요치 않을 때
 * 자식 프로세스는 부모 프로세스가 종료된 후에는 존재할 수 없음
 * 부모 프로세스가 종료된다면 그 자식 프로세스는 모두 종료
 * 이러한 현상을 연속적 종료라 하며 보통 운영체제 의해 실행

 (3) 교착상태
  * 운영체제에서 프로세스들이 서로 작업을 진행하지 못하고 영원히 대기 상태로 빠지게 되는 현상
  * 둘 이상의 프로세스들이 서로 다른 프로세스가 차지하고 있는 자원을 요구할 때 무한정 기다리게 하여, 결국 해당 프로세스의 진행이 중단되는 현상
  * 요청한 자원이 영원히 할당되지 않으면 해당 프로세스는 계속 기다리게 되므로 이를 교착상태라함	
  * 교착상태 발생하면 프로세스는 작업을 완료하지 못하고 시스템 자원을 묶어 놓음으로써 다른 프로세스 조차 그 시스템 자원을 사용치 못하게 함
  * 교착상태 방지하기 위해 2개 이상의 프로세스가 하나의 자원을 공통으로 사용한다면 이들에 대한 적절한 자원 할당해야함
  * 교착상태의 발생 조건
      1) 상호배제
         - 공유할 수 없는 자원, 즉 한번에 하나의 프로세스만이 독점할 수 있는 자원을 하나 이상 가지고 있는 경우
    	 - 공유될 수 없는 자원이란 프린터와 같이 결코 여러 프로세스가 동시에 사용할 수 없는 자원을 의미
    	 - 반면에 공유할 수 있는 자원은 상호배제적인 액세스를 요구하지 않기 때문에 교착상태가 일어나지 않음
    	   예) 읽기 전용 파일과 같은 자원은 동시에 몇 개의 프로세스라도 공유할 수 있으며, 프로세스는 공유 자원을 액세스하기 위해 대기할 필요가 없으므로 교착상태가 일어나지 않음
      2) 환형대기
         - 프로세스간의 환형 사슬이 존재해서 이를 구성하는 프로세스는 사슬 내의 다음에 있는 프로세스가 요구하는 하나 또는 그 이상의 자원을 갖고 있음
    	 - 프로세스 집합(p0,p2,..,pn)에 있어서 p0는 p1에 할당된 자원을, pi는 pi+1에 할당된 자원을, 그리고 pn은 p0에 할당된 자원을 요청하며 대기
      3) 비선점
         - 할당된 자원을 프로세스가 모두 사용하기 전에는 그 프로세스로부터 자원을 강제로 빼앗을 수 없고, 그 자원을 점유하고 있는 프로세스가 끝나야 그 자원이 해제되는 상태를 말함
      4) 점유와 대기
         - 프로세스가 자신이 점유한 자원을 해제하지 않은 상태에서 다른 프로세스가 점유한 자원이 할당되기만을 기다리는 상태를 말함
  * 교착상태의 방지
      1) 상호 배제의 방지
         - 상호배제 조건은 공유될 수 없는 자원에서 반드시 따르는 조건
         - 일반적으로 상호배제 조건을 거부함으로써 교착상태를 방지할 수 없음
         - 몇몇 자원들은 본직적으로 공유할 수 없는 것이 있음
      2) 점유와 대기의 방지
         - 프로세스를 수행하기 전에 필요하게 될 모든 자원을 한꺼번에 요청하고 할당받음
    	 - 각 프로세스는 자원을 하나도 갖고 있지 않을 경우에만 자원을 요구하할 수 있음
      3) 비선점의 방지
         - 만일 어떤 자원을 이미 할당 받은 프로세스가 또 다른 자원을 요청했는데 그것을 즉시 사용할 수 없는 상황이라면 현재 할당되었던 모든 자원을 선점시킴
    	 - 즉, 이 모든 자원은 묵시적으로 해제됨. 선점된 자원은 그 프로세스가 기다리고 잇는 자원들의 리스트에 추가시키고, 프로세스는 그 리스트 내의 모든 자원을 얻을 경우에만 다시 시작할 수 있도록 함
    	 - 만일 프로세스가 어떤 자원을 요청하면 먼저 그 자원의 가용 여부를 조사하여 가용 상태이면 할당한다. 그러나 바로 할당할 수 없는 상태이면 그 자원이 다른 자원이 다른 자원을 기다리고 있는 프로세스에 할당되어 있는 지를 조사한다. 만일 그렇다면 대기 상태인 프로세스로부터 자원을 선점하여 요청한 프로세스에게 할당해줌
    	 - 자원이 가용 상태가 아니거나 대기 상태인 프로세스에 의해 소유되고 있으면 요청한 프로세스는 반드시 대기해야 함. 대기 상태인 프로세스에 의해 소유되고 있으면 요청한 프로세스는 반드시 대기해야함. 대기 상태일 경우 다른 프로세스가 자신의 자원을 요구할 때는 그 자원은 선점하게 됨
         - 대기 상태에서 자신이 자원이 강제 해제된 프로세스는 기다리던 자원을 할당 받았을 때 강제 해제된 자원을 다시 요청하여 할당 받은 후에 작업을 수행하게 됨.
    	 - 결론적으로, 비선점 조건을 방지하기 위해서는 하나의 프로세스가 자기에게 필요한 자원을 확보하기 위해서는 그 자원을 가지고 있는 다른 프로세스를 중단시킬 수 있도록 함
      4) 환형 대기의 방지
         - 환형대기 조건을 막기 위해서는 모든 자원의 유형에 일련번호를 지정
         - 각 유형에 유일한 자연수를 대응시키는 것
         - 프로세스는 자원을 항상 오름차순으로 요청하도록 함
         - 프로세스는 초기에 어떤 자원 n을 지닐 수 있다.		 
  * 교착상태의 회피
      - 교착상태 방지 알고리즘을 적용하여 교착상태를 방지하게 되면, 시스템 자원을 미리 선점하는 등의 이유로 장치 이용률과 시스템 성능이 저하되는 부작용이 생김
      - 이에 따라 교착 상태의 회피 알고리짐이 있음
      - 교착상태이 회피 : 자원에 관한 상태 정보(자원의 최대 수, 사용 가능한 자원 수, 프로세스의 최대 요구 수)를 이용하여 프로세스에게 자원을 할당할 떄 교착상태를 회피할 수 잇는 안정 상태를 유지하도록 능동적으로 조정하는 방법
      - 교착상태 방지 vs 교착상태 회피
        : 교착상태 회피는 교착상태가 일어날 가능성은 있지만 자원 할당 시에 주의하여 교착상태가 발생하지 않도록 안정 상태를 유지하는 방법
      - 회피 알고리즘은 은행원 알고리짐과 비슷
         - 운영체제는 자원의 상태를 감시
         - 사용자 프로세스는 사전에 자기 작업에서 필요한 자원의 수를 제시
         - 운영체제는 사용자 프로세스로부터 자원의 요청이 있으면 모든 프로세스가 일정 기간 내에 성공적으로 끝날 수 있는 안전 상태인지를 면밀하게 분석
      - 운영체제는 안전 상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자 프로세스의 요청은 나중에 만족될 때까지 계속 거절		 
  * 교착상태의 탐지
      - 만일 시스템에 교착상태 방지나 교착상태 회피 알고리즘이 적용되고 있지 않으면, 교차상태를 탐지하고 복구시킬 수 있는 체제가 대신 필요
      - 우선 시스템의 상태를 조사하는 알고리즘을 주기적으로 수행
      - 교착상태가 발생하였는지 여부를 조사
      - 만약 교착상태가 발생하였다면 시스템은 이 교착상태로부터 복구할 수 있는 조치
      - 교착상태 탐지 알고리즘은 즉시 받아들여질 수 없는 자원 할당 요구가 있을 때마다 수행되어야함
  * 교착상태의 복구
      방법1
      - 교착상태에 빠진 모든 프로세스들을 중지(Kill) 시키는 방법
      - 임의의 프로세스를 종료 시키는 것은 쉽지가 않음
      - 만약 프로세스가 파일을 갱신 중이었다면, 그 프로세스를 중도에 종료시키는 것은 파일을 부정확한 상태에 있게 만들면 됨
      - 프로세스가 프린터로 자료를 출력 중이었다면, 시스템은 다음 작업의 출력이 이루어지기 전에 프린터의 상태를 올바르게 해주어야함
      방법2
      - 교착상태에 있는 하나 이상의 프로세스들로부터 몇 개의 자원을 선점시키는 방법
      - 프로세스로부터 자원을 선점한다면, 그 프로세스를 어떤 상태로 놓을 것인지를 결정해야함
      - 정상적 수행을 계속할 수 없다는 것이며, 따라서 그 프로세스는 어떤 필요한 자원을 잃어버리게 됨
      - 프로세스를 안전한 상태로 되돌려 놓아야 하며, 그 상태로부터 재시작해야함
  * 교착상태 처리의 복합적 접근
    - 방지, 회피, 탐지, 복구와 같은 방법들이 독자적으로 사용되어 운영체제에 발생하는 자원할당의 문제의 전체 영역에 모두 대처할 수 없음
    - 기본적인 방법들을 복합적으로 사용하면 보다 적절한 처리가 가능
    - 한가지 방안은 자원을 유형에 따라 계층적으로 분류할 수 있다는데 기초
    - 구분된 각 계층별로 최적의 기법을 선택하여 적용시키는 것
    - 각 계층에 대하여 자원 순서를 부여함으로써 전체 시스템은 교착상태를 피할 수 있음
    - 내부 자원 선택 시 : 각 자원에 번호를 부여하여 할당하여주는 교착상태가 적합
    - 주기억장치 선택 시 : 작업은 교체(Swap)가 가능하므로 선점을 통한 교착상태 방지가 적합, 그리고 CPU도 선점될 수 있음
    - 외부자원 선택 시 : 자원에 대한 정보를 관리함으로써 교착상태 회피가 사용될 수 있음

# 속도계층 (speed layer)

일괄처리 계층의 긴 지연시간을 보완하여 입력 질의에 대해 최신 결과를 내어질 수 있게 하는 계층



## 1. 속도 계층은 아직 서빙 계층에 포함되지 않은 데이터만 맡아서 처리하면 됨.

길어야 수 시간 이내에 만들어진 것이고 마스터 데이터 집합에 비하면 훨씬 작음



## 2. 속도 계층의 뷰는 일시적으로만 유효함

속도 계층에 있던 데이터가 서빙 계층 뷰쪽으로 들어간 다음에는 일시적으로 유효함.

-> 만약 속도 계층에서 오류가 발생하더라도 단순하고 확실한 일괄처리 계층 및 서빙 계층을 거치면서 자동으로 고쳐짐.



* 참고) 람다 아키텍쳐의 위력

서로 다른 계층에 개별적인 역할을 부여



* 속도 계층의 동작
  1. 실시간 뷰를 저장
  2. 입력으로 들어오는 데이터 스트림을 처리해서 뷰를 갱신



### 실시간 뷰 계산하기

* 실시간 뷰의 기본적인 목적 : 효율적으로 질의 처리가 가능하게 만드는 뷰를 만들어 내는 것 => 일괄처리, 서비 계층의 목적과 동일
* 최신 데이터만 대표한다는 것과 새 데이터가 들어오면 짧은 시간안에 갱신되어야 함
* 서빙 계층을 흡수되기 전의 데이터 전체를 대상으로 뷰를 만드는 것
  * 지연시간, 사용 특성을 고려할 때 다수의 애플리케이션에서 실용적이지 못함. (예: 서빙계층으로 갱시되는 주기가 6시간이라고 가정할 때, 그 6시간동안의 데이터가 엄청나게 많을 때)



### 실시간 뷰 저장하기

* 속도 계층의 요구사항 (NoSQL 과 비슷)
  * 무작위 읽기
  * 무작위 쓰기
  * 확장성
  * 내결함성
* 키/값의 형태 색인을 저장하려면 카산드라를 사용, 검색 질의를 지원하려면 엘라스틱서치 사용



### 최종적 정확성

* 모든 데이터가 최종적으로 일괄처리 및 서빙 계층 뷰에서 표현되기 때문에, 속도 계층에서 사용된 근사값은 지속적으로 수정됨.
* 모든 데이터가 최종적으로 일괄처리 및 서빙 계층 뷰에서 표현되기 때문에 속도 계층에서 사용된 근사값은 지속적으로 수정됨. -> 이 근사값은 일시적이고 질의 결과는 최종적으로 정확함.



### 속도 계층에 저장되는 상태의 양

* 속도 계층은 최신 데이터를 대상으로 뷰를 만들기 때문에 다른 계층에 비해 저장되는 상태의 양이 상대적으로 작음
* 실시간 뷰의 복잡성
  * 디스크 공간 회수 필요 : 읽기/쓰기 데이터베이스에 갱신이 들어오면, 기존에 만들어둔 디스크 색인은 일부가 미사용 상태로 되면서 공간을 잡아먹게 되어, 주기적으로 디스크 공간 회수(압밀화)가 필요
  * 동시성
* 속도 계층은 몇시간, 또는 몇분 데이터만 책임을 짐으로 작게 구성될 수도 있음



### 증분식 계산의 어려운 점

* CAP 정리
  * 일관성 (consistency) : 이전에 발생한 쓰기가 모두 마무리된 후에 읽기 작업이 이루어져야함
  * 가용성(availability) : 모든 질의에 대해 오류(장애)없이 답을 보장
* 일관성을 선택한다면? 이 시스템에 던지는 질의는 정답 대신 오류를 받을 수도 있음
* 가용성을 선택한다면? 분단이 지속되는 동안에 오래된 값을 읽을수도 있음



### CAP 예

* 분산 시스템에서 몇대의 장비가 통신이 되지 않을때?
  * 여러 서버에 데이터를 복제하면 분산 시스템의 내결함성을 강화할 수 있음
* 네트워크가 끊긴 상태에서 어떻게 쓰기 작업을 할까?
  * 선택1 : 모든 복제본이 동시에 갱신될 수 없도록 갱신 수행 거부
  * 선택2 : 갱신 가능한 복제서버 내의 복제본을 일단 갱신하고 네트워크 분단이 해결되었을 때 다른 복제본들과 동기화 (복제본을 병합하는 일은 복잡)



### scale-out 에서 CAP 복잡한 점

* 어떤 시스템에서 가용성을 채택했을때, 네트워크가 끊겼으 ㄹ때 처음에는 같은 값을 가진 복제본들이 독립적으로 갱신됨.

* 네트워크 분단이 해소된 후에 이 들을 모두 합쳐서 갱신해야함.

* 예) 어떤 복제본은 조회수가 110이고 다른 복제본은 조회수가 105일때? -> 정답은 0~215 어딘가

* 최종 일관성을 갖춘 카운트를 올바르게 구현하기 위해 CRDT라는 자료 구조사용해야함

  ![CRDT](http://jtfmumm.com/blog/diagrams/g-counter-semi-lattice.png)

* 속도 계층에 최종적 일관성 넣고 싶다면?

  * 람다 아키텍쳐는 실수로부터 시스템을 보호하는 능력을 구조적으로 가지고 있음
  * 일괄처리 및 서빙 계층이 이후에 최종적으로 자동적으로 실수를 수정해줌.



## 비동기식 vs 동기식 갱신

* 속도 계층은 비동기식으로 처리할지 동기식으로 처리할지에 따라 다름.
  * 동기식 : 데이터베이스에 요청을 보내고 갱신이 모두 처리될 때까지 다른 동작을 막음
  * 비동기식 : 나중에 진행될 갱신들을 큐에 넣음.
* 비동기식 장점
  * 큐에서 여러개의 메시지를 읽고 데이터베이스에 일괄 갱신을 수행할 수 있어서 처리량을 높일 수 있음
  * 들어오는 부하의 변동에 대해서도 즉시 대응 가능
  * 예) 트레픽이 클 때



### 실시간 뷰 만료시키기

* 실시간 뷰 2개를 교대로 비우는 방법을 쓰면, 2개 조중 하나는 속도 계층에서 담당해야할 데이터를 들고 있음

![image](https://image.slidesharecdn.com/final-141228043453-conversion-gate02/95/speed-layer-real-time-views-in-lambda-architecture-27-638.jpg?cb=1419741511)





### 카산드라(Casandra)

* 속도 계층에서 실시간 뷰로 사용할 수 있는 데이터베이스
* 예

[foo.com/blog,d] -> 0 : 132

​                                   2->254

​                                   3->235

​                                  4->235

​                                  5->120

[bar.com/page,d]-> 0 : 132

​                                   2->254

​                                   3->235

​                                  4->235




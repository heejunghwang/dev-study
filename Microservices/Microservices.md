# - 소개

"Microservices" 이라는 용어는 새로운 소프트웨어 개발 스타일이다. Microservices는 소프트웨어 개발/관리 실행의 최근 트랜드로 크고있다. 이 실행으로, 개발의 속도와 대규모 소프트웨어 솔루션의 관리를 효율성을 올릴수 있다.

Agile 방법, DevOps 문화, 클라우드, Linux Conatainers, 산업을 넘은 CI/CD methods의 전반적인 선택(문화적이나 기술적으로) 등은 진정하게 내부적, 상업적으로 사용할 수 있는 모듈화된 큰 서비스에 최적화된 시스템을 만드는 것을 가능하게 하였다.

 

# - Microservices란?

Microservices는 아키텍쳐적인 접근을 포함하고 있다. 어플리케이션을 한가지 목적으로 분리하는 것, 응집력은 높고, 낮은 결합도를 가진 교차 가능한 팀으로 관리되는 서비스를 강조한다. 요새 디지털 비즈니스에서 요구하는 속도와 퀄리티로, 복잡한 시스템을 전달하고 관리하기 위함이다.

Microservices는 언어, 플랫폼(platform), 시스템에 구속받지 않는다. 이것들은 큰 한 단위의 어플리케이션(일반적으로 하나의 아카이브로 패키지되고 이것은 수직적으로 커지거나(scale-out) 수평적으로 확장(scale-up)된다.)을 작은 단위나 심플한 서비스로 쪼갤 수 있다. 각각의 Microservices는 1개이고, 잘 되고, Microservices에서 "micro"는 서비스의 기능성을 의미하고, 코드의 길이를 뜻하지는 않는다.

각각의 Microservices는 일반적으로 풀스택 팀에서 만들어지고, 문제점이 있을 수 있는 다른 팀과의 커뮤니케이션의 잠재적인 어려움을 감소시킨다.

Microservices는 간단한 어플리케이션에 적합하지 않고, 시간이 지나면서 커지고, 큰 코드베이스와 팀들을 가진 복잡한 어플리케이션에 적합하다. Microservices는 다양한 비즈니스 function을 실현하는데 적합하다. 하나의 Microservices는 1가지 비즈니스 Function이나 sub-function에 집중한다. 팀들은 그들의 페이스에 따라서 자유롭게 혁신할 수 있다.

자주 업데이트 되어야 하는 어플리케이션의 빈도와 Microservices 디자인을 사용하는 것을 가능하게 하는 빠른 전환은 이러한 아키텍쳐의 스타일을 만드는 주요 요소이다. Microservices의 컨셉은 SOA(ServiceOriented Architecture)와 비슷하다. (“SOA with DevOps,” “SOA for hipsters,” and “SOA 2.0”. 이렇게도 불려왔던 아키텍쳐의 스타일이다.)

# - Microservices의 키워드

**1. Domain-Driven Design**

- Eric Evans의 DDD접근을 사용하여 기능적인 분리를 달성할 수 있다.

**2. Single Responsibility Principle (단 한개의 책임 원칙)** 

- 각각의 서비스는 잘 되는 기능성의 한 일부분의 책임을 가지고 있다.

**3. Explicitly Published Interface(명시적으로 공개된 인터페이스)** 

- 프로듀서(producer) 서비스는 컨슈머(consumer) 서비스에서 사용되는 인터페이스를 공개한다.

**4. Independent DURS (Deploy, Update, Replace, Scale) (독립적인 DURS(배포, 업데이트, 교체, 확장))** 

- 각각의 서비스는 독립적으로 배포, 업데이트, 교체, 확장될 수 있다.

**5. 똑똑한 Endpoints와 Dumb Pipes** 

- 각각의 Microservices는 그것의 도메인 로직을 가지고 있으며, HTTP를 넘어 REST와 같은 간단한 프로토콜과 커뮤니케이션 한다.

 

# - Microservices의 장점

**1. 독립적인 확장(INDEPENDENT SCALING)**
각각의 Microservice는 필요할 때, X-축 확장(CPU나 메모리로 복제)을 통해 직접적으로 확장될 수 있고, Z-축 확장(샤딩(sharding))할 수 있다. 이것은 단일적인 어플리케이션과 매우 다른데, 단일적인 어플리케이션은 다양한 요구사항을 가지고 있지만, 1개의 유닛으로 같이 배포가 되어야만한다.

**2. 독립적인 업그레이드(INDEPENDENT UPGRADES)**
각각의 서비스는 다른 서비스와 독립적으로 배포될 수 있다. 다른 팀과의 화합하지 않고, 개발자가 변경한 로컬을 서비스로 만들어질 수 있다. 예를 들면, 비즈니스 요구사항이 변경될 때, 서비스는 하부단의 구현만 교체해서 요구사항을 적용할 수 있다. 이것은 CI/CD보다 더 유능하다.

**3. 쉬운 유지보수(EASY MAINTENANCE)**
Microservices에서 코드는 1가지 역량으로 제한하기 때문에, 이해하기 쉽다. IDE는 코드의 작은 양을 로드할 수 있고, 작은 코드베이스(code base)는 코드 개발자가 현재 작성중인 side effect을 인지함으로써 속도를 높인다.

**4. 잠재적인 이질성과 여러 언어로 사용(POTENTIAL HETEROGENEITY AND POLYGLOTISM)**
개발자들은 언어를 선택하는데 자유롭고, 그들의 서비스에 stack이 가장 적절하다. 그들은 서비서의 한계내에서 자유롭게 혁신할 수 있다. 이것은 새로운 신기술을 사용해서 다시 작성하는것을 가능하게 한다. 이것은 금지되었던과는 과거의 결정과 반대된다. 그리고 이것은 기술이나 툴이나 프레임워크를 사용할때 자유를 준다.

**5. 실패와 리소스 분리(FAULT AND RESOURCE ISOLATION)**
메모리 누수나 데이터베이스의 연결을 닫지 않는 잘못된 서비스는 그 서비스에만 영향을 미칠 것이다. 이것은 전체 단일적인 어플리케이션과는 반대된다. 이것은 잘못된 분리를 향상시키고 어플리케이션 실패의 한계를 영향을 미칠 수 있다. 잘 디자인된 Microservices와 함께, 실패는 단일 서비스에서 분리될 수 있고, 나머지 시스템에 전파하지 않을 수 있는데 이것은 취약성(anti-fragility)을 명백하게 나타낼 수 있다.

**6.팀간의 의사소통을 높임(IMPROVED COMMUNICATION ACROSS TEAMS)**
Microservices는 일반적으로 풀스택 팀에서 만들어진다. 모든 멤버는 하나의 팀내에서 domain 일과 관련되어 있다. 이것은 팀멤버간의 의사소통을 높여주는데, 그들은 최종 목표를 공유할 수 있고, 박자를 맞출 수 있고 아마도 대부분 중요하게도 그들의 서비스는 그들의 제품이 되고 그들은 제품 환경에서도 전반적으로 책임이 있다.

 

# - Microservices 에서의 운영 요구사항

Microservices는 어플리케이션에서 아키텍쳐적인 모드는 문제를 해결하는 묘책이 아니다. Microservices로 구현하는것은 아마도 도움이 되겠지만, 때로는 어플리케이션을 리팩토링하는데 부작용이 될 수 있다. 특히, 이러한 아키텍쳐 스타일을 요구되는 가이드라인를 사용하는 코드를 다시 작성할때이다. 진정한 성공은 거대한 투자를 요구한다.

1. 서비스 복제(SERVICE REPLICATION)
각각의 서비스는 복제가 필요한데, 특히 x축 복제나 Y축으로 나눌때이다. 표준적인 매카니즘이 있어야 하는데, 이 매카니즘은 메타데이터에 의해서 쉽게 확장이 가능해야한다. Red Hat에서의 OpenShift 같은 최적화된 컨테이너 어플리케이션 플랫폼은 기능성을 간소화 할 수 있다.

2. 서비스 발견(SERVICE DISCOVERY)
Microservices 세계에서는, 다양한 서비스는 특히 컨테이너 어플리케이션 플랫폼에서 분배된다. 변경할 수 없는 인프라 구조는 컨테이너나 VM 이미지로 제공된다. 서비스는 이미 정의된 특정 메트릭스에 의해서 확장되거나 축소될 수 있다. 서비스의 정확한 주소는 서비스가 배포되거나 사용되기 전까지 알 수 없다. 서비스의 endpoint 주소가 동적인 습성은 서비스의 등록이나 발견에서 처리된다. 

3. 서비스 모니터링(SERVICE MONITORING)
배포되는 시스템에서 가장 중요한 특징은 모니터링과 로깅이다. 이것은 행동을 주도하는데, 예를들면 서비스가 예상치 못한 자원을 소비한다. Elasticsearch, Fluentd, Kibana 는 그것들을 계속 보여주고, 비즈니스 사용자가 데이터를 만들어줄 수 있다.

4. 탄력(RESILIENCY)
얼마나 테스트를 열심히 해도 소프트웨어의 실패는 일어난다. 이것은 인터넷을 통해 다수개의 Microservices가 배포될때 더욱 중요하다. 주요 걱정은 "실패를 피한다"가 아니라 "실패를 어떻게 대응하는가"이다. 이것은 서비스에 중요한데, 자동적으로 사용자가 영향을 받지 않도록 작동을 한다. Circuit Breaker 패턴은 소프트웨어에서 탄력을 받을 수 있도록 한다. - Netflix’s Hystrix는 이 패턴을 적용시키는 것을 구현하는 좋은 라이브러리이다.

5. DEVOPS
지속적 통합이나 지속적 개발(CI/CD)는 Microservices 기반의 어플리케이션을 성공하는데 매우 중요하다. 이러한 방법은 잘 자동화된 테스트나 개발 파이프라인을 통해서 에러가 빨리 식별될 필요가 있다.

 

# - 존재하는 단일 조직(MONOLITHS)을 위한 좋은 디자인 원칙

Microservices 기반의 어플리케이션으로 하나의 어플리케이션(MONOLITHS)을 리팩토링 하는것은 모든 아키텍쳐 이슈를 해결할 수는 없다. 하나의 어플리케이션(MONOLITHS)을 쪼개기 전에, 하나의 어플리케이션(MONOLITHS)이 좋은 소프트웨어 아키텍쳐 원칙에 설계되는 것을 확실하게 하는것이 중요하다. 몇몇 일반적인 규칙은 다음과 같다.

1. 문제점을 나누어라. front-end 추상화를 위한 Model-View-Controller(MVC)를 고려해봐라. 높은 응집력과 낮은 결합도를 가진 잘 정의된 API를 사용해라. 인터페이스와 API들과 구현을 분리하여라.

2. 설정의 관례(GoC)를 사용하라. 관례를 사용하거나 설립을 최소화된 설정을 계속해라.

3. Law of Demeter 를 사용하라. 각각의 유닛은 다른 유닛들의 한정된 지식을 가지고 있어야 한다.: 유닛들은 지금 유닛과 "매우 밀접하게" 관련되어야 한다. 각각의 유닛은 친구들에게 말을 해야한다.:낯선 사람에게 말하지 않는다. 즉각적인 친구들과만 이야기 해야한다.

* 참고) Law of Demeter
각 계층은 다른 계층에 대해 오직 제한된 정보만을 가질 수 있다

4. DDD(Domain-Driven Design)를 사용하라. 도메인/컴포넌트와 같이 객체를 하라.

5. 자동화에 초점을 맞추어라. 제품에 반대되는 테스트에 자동화를 해라. - 예를 들면, 개발 환경에서 배포나 전체적인 배포 파이프라인의 제작은 남아있는 큰 덩어리와 함께 붙어 있더라도 가치를 제공할 것이다.

6. Interface/API들을 디자인해라. Class들은 다른 클래스를 직접적으로 호출하면 안된다. 왜냐하면, 같은 곳에서 발생할 수 있기 때문이다. 매우 연관이 있는 클래스들은 Microservices로 나중에 추출될 것이다. Microservices로 옮기더라도, 정화된 인터페이스는 클라이언트에게 발견되도록 할 것이며, 그 기능을 사용하게 할 것이다.

7. 기능별로 코드를 그룹화하고, 레이어하지 말라. 큰 덩어리는 아키텍쳐에서 대체적으로 레이어된 아키텍쳐를 가지고 있고, 레이어별로 class들을 그룹화 한다. 대신에, 기능별로 쪼갠 패키지로 코드를 쪼개야 한다. 이것은 추후에 Microservices에서 쪼개는 것을 쉽게 하고, Microservices들 사이에서의 의존성을 보는것을 쉽게 할 것이다.

8. 코드를 상태가 없도록 만들고, 어플리케이션의 상태를 표면화 하라. 어플리케이션의 상태의 소스에서 한개는 static 변수나 global 변수에 의존할 수 없다. 상태를 관리하기 위해서, 키-값(key-value) 저장이나 데이터베이스와 같은 외부 소스를 사용해라.

 

# - REFACTORING A MONOLITH TO MICROSERVICES (단일 서비스에서 Microservices로 리팩토링)

Java EE 단일화된 어플리케이션에서 WAR나 EAR 아키브를 주로 정의를 했었다. 어플리케이션을 위한 전체적인 기능은 하나의 유닛으로 묶음이 된다. 예를 들면, 온라인 쇼핑 카트는 User, Catalog, Order 기능을 가지고 있다. 모든 웹 페이지들은 어플리케이션에서의 root에 있고, WEB-INF/classes 디렉토리 안에 있거나, 모든 리소스들은 WEB-INF/classes/META-INF 디렉토리에 있다.

이러한 어플리케이션은 Microservices로 리팩토링 될 수 있다. 이것은 다음과 같은 특성을 포함한다. :

위와 같은 어플리케이션은 User, Order, Catalog 컴포넌트와 같이 분리된 War 파일로 기능적으로 분리가 되어있다. 각각의 War 파일들은 요구되는 컴포넌트에 웹 페이지, class, 설정파일들과 관련이 있다.

JavaEE는 각각의 컴포넌트로 구현되도록 사용되었으나, 장시간 공헌에 대한 것은 없었다. 각각의 컴포넌트들은 잘 정의된 API를 사용하여 대화할 수 있다.

컴포넌트에서 다른 classes들은 같은 도메인에 속해있으므로, 코드는 쓰고 관리하기가 쉽다. 이러한 스택은 바꾸고 쉽고, 작은 단위로 기술적인 의심을 가질 수가 있다.

각각의 아키브는 각각의 database를 가지고 있다. (예: 데이터 저장은 공유되지 않는다) 이것은 어떠한 가장 적합한 데이터 저장소를 고르고 사용할 수 있다. - 관계, NoSQL, flat file, in-memory 등.

각각의 컴포넌트는 Service Registry와 함께 등록할 수있다. 이것은 각각의 서비스에서 많은 상태가 없는 인스턴스에서 주어진 시간에 작동할 수 있도록 하고, 정확한 endpoint 위치는 런타임시에 알 수 있다. Kubernetes, Netflix Eureka, etcd, Zookeeper 는 서비스를 등록/발견을 구현하는 옵션이다.

만약 컴포넌트들끼리 이야기를 해야한다면, (물론 흔하지만...) 미리 정의된 API를 사용한다. 동기를 위한 REST, 비동기를 위한 Pub/Sub 대화는 이것을 아키브하는 가장 흔한 도구이다. 이 케이스에서, Order 객체는 User와 Catalog 서비스를 발견하고, REST API를 사용하여 이야기한다.

어플리케이션을 위한 클라이언트 교류는 다른 어플리케이션에 정의되어있다. (이 케이스에서는, Shopping Cart UI) 이 어플리케이션은 Service Registry에서 서비스를 발견하고, 함께 구성한다. 이것은 대부분 dumb proxy이다. (다음 section에서 소개 예정) 다른 컴포넌트에서의 UI 페이지에서 실행이 된다. 일반적인 느낌은 제공된 표준적인 CSS/JavaScript 리소스를 사용하여 아키브 된다.

 

# - MICROSERVICE에서의 패턴

**1. Microservices를 위한 후보군을 식별하기 위해서 Context를 바운딩을 사용하라.** 
바운딩된 내용(domain-driven 디자인에서 패턴)은 단일화된 어플리케이션에서 어떠한 도메인 모델의 부분이 Microservices로 분리될 수 있는지 식별하는데 좋은 방법이다. 이상적인 분리에서, 모든 바운드된 context는 각각의 Microservices로 추출될 수 있고, 비슷한-잘 정의된 API를 통한 추출된 Microservices와 대화할 수 있다. 고객들과 Microservices의 모델 클래스를 공유하는 것은 필수가 아니다.; 모델 객체는 숨겨져야하고, Microservices 사이에서 binary 의존성을 최소화 하길 원하기 때문이다.

단일화된 시스템을 분해하는 과정에서 부패 방지 레이어의 사용은 강하게 권고된다. 부패 방지 레이어는 Microservices에서 모델을 Microservices 소비자들에게 영향을 미치지 않고 바꿀 수 있다.



**2. Microservices를 위한 프론트엔드**

기존의 단일화된 시스템에서는, 한 팀은 프론트엔드를 개발하고 유지보수 했어야 했다. Microservices 아키텍쳐에서는, 여러개의 팀이 기여할 수 있고, 이것은 다루기 힘든 문제들을 쉽게 늘릴 수 있다.

이것은 프론트엔드의 여러가지 파트를 나눔으로써 해결할 수 있는데, 각각의 Microservices 팀은 상대적으로 분리된 관점으로 개발할 수 있다. 각각의 Microservices 팀은 자신들의 컴포넌트에서 개발하고 유지보수 할 것이다. 프론트엔드의 다양한 부분의 변화는 컴포넌트에 캡슐화 될 것이고, 다른 프론트엔드 부분로 새어나가지 않을 것이다.



**3. Microservices로 중앙화된 접근의 사용을 위한 API 게이트웨이**
Microservices에서 클라이언트 역할을 하는 프론트엔드는 각각의 다른 Microservices로 부터 데이터를 가져올 것이다. 이러한 Microservices는 web(HTTP+JSON/XML)에게 네이티브적으로 프로토콜로 응답할 수 없을 것이다. 그러므로, 하나의 프로토콜에서 다른 프로토콜로 메세지 해석이 필요하다. 인증과 승인과 같은 걱정, 다른것과의 응답-요청 번역은 정면적이고 중앙집중적인 관점으로 다루어질 것이다.

API 게이트웨이의 사용을 고려할 때, API 게이트웨이는 네트워크 주위에서 앞서 말한 걱정을 중앙화하는것을 정면적으로 해야한다. 명확하게, API 게이트웨이는 Microservices에 의해 선호되는 관점을 사용하여 Microservices와 통신하는동안, 웹에게 네이티브 프로토콜을 넘어서 클라이언트 요청에 응답할 것이다. Microservices에서의 클라이언트는 OAuth와 같은 토큰 인증 스키마를 통해서 API 게이트웨이를 식별화할 것이다. 이 토큰은 하단에서 방어적인 집행을 다운스트림 Microservices에게 다시 유효성 확인을 할 것이다.



**4. 데이터베이스 디자인과 리팩토링**
하나의 데이터베이스를 사용하는 단일화된 어플리케이션과는 달리, Microservices는 각각의 Microservices를 위한 논리적인 데이터베이스를 분리를 고려해야한다. 데이터베이스의 공유는 권고되지 않고, 안티패턴이다. 왜냐하면 데이터베이스 스키마가 업데이트 되는 시점마다 하나 이상의 팀에게 기다리게 하기 떄문이다.; 데이터베이스는 팀 사이에서 필수적인 API가 되었다. 한 사람은 데이터베이스 스키마, 데이터베이스 객체의 분리된 네임스페이스를 생성하기위한 논리적인 스키마를 사용할 수 있는데, 다양한 물리적인 데이터베이스의 생성을 필요를 막을 수 있다.

추가적으로, 단일화된 아키텍쳐에서 Microservices 아키텍쳐로 마이그레이션할땐, Liquibase나 Flyway 와 같은 데이터베이스 마이그레이션 툴을 사용할 수 있다. 단일화된 데이터베이스는 모든 Microservices로 복제되어야만했고, 이 마이그래이션은 데이터베이스를 소유하는 Microservices에 적절하게 변형되고 추출되도록 모든 데이터베이스에 적용되어야 했다. 단일화된 아키텍쳐에서 기존 데이터베이스에서 모든 객체를 각각의 Microservices에 관심을 가질 필요가 없다.



**5. Packing과 배포 서비스**
각각의 Microservices는 외부의 의존성을 분리하여 팀에게 개발하고 유지보수하는 것을 원칙적으로 기술적인 스택을 사용할 수 있다. Microservices 아키텍쳐에서 하나의 기관은 다양한 런타임 플랫폼(Java/JVM, Node, .Net 등)을 사용할 수 있다. 이것은 잠재적으로 데이터 센터의 host/node들에 다양한 런타임에서 문제점을 들어나게 된다.

시각화된 기술의 사용을 고려하라. 이것은 각각 패키지되고 배포하는 기술적인 스택을 가능하게 한다. 이것은 이후에, 경량화된-시각화된 기술로서의 Microservices를 가능하게 하는 컨테이너의 사용을 고려하게 된다. 그리고 런타임 환경은 하나의 이미지로 패키지 되어야한다. 컨테이너에서, 하나는 packaging의 필요성을 잊게하고, host OS에서 게스트 OS로 작동하게 한다. 이렇게 되면, Kubernetes와 같은 통합 컨테이너 기술을 고려하라. 이것은 설정파일, OpenShift와 같은 컨테이너 플랫폼에서 다양한 배포를 정의를 가능하게 한다. 설정파일은 다양한 컨테이너와 관련 정책과 함께 데이터센터의 의도된 상태를 정의하고, 이것은 DevOps 문화를 퍼지게 하는것을 가능하게 하며, 개발팀과 운영팀을 넘어 성장할 수 있게 한다.

**6. 이벤트 주도적(EVENT-DRIVEN) 아키텍쳐**
Microservices 아키텍쳐는 아키텍쳐에서 상태를 저장하는 다양한 데이터 저장소를 고려했을때, 결국 일관적인 것으로 잘 알려져있다. 각각의 Microservices는 엄청나게 일관적이지만, 전체적인 시스템에서는 부분적으로 궁극적인 일관성을 보여줄 것이다. Microservices 아키텍쳐의 궁극적인 일관성 프로퍼티를 설명하기 위해서, 이벤트 주도적 아키텍쳐의 사용을 고려해야한다. 이벤트 주도적 아키텍쳐는 Microservices에서 데이터 변화는 이벤트에서의 관심있는 Microservices에 달려있다.

Pub-Sub 메세징 아키텍쳐는 이벤트 주도적 아키텍쳐를 실현할 수 있다. 하나의 Microservices는 context에서 발생한 이벤트를 배포할 수 있고, 이벤트는 모든 관심있는 Microservices와 통신할 수 있고, 이것은 그들의 상태를 업데이트를 진행할 수 있다. 이벤트들은 하나의 서비스에서 다른 서비스로 전환하는 도구이다.

**7. CONSUMER-DRIVEN 접촉 테스트**
개발하는 동안 변화가 수행된 변화의 정확성을 검증하기 통합 테스트 사용한다. 그러나, 이것은 비용이 비싼 프로세스이다. 따라서, 이것은 Microservices, Microservices의 의존성, Microservices의 모든 고객에게 권장을 필요로 하고, Microservices에서 소비자의 기대를 깨지않는 변화를 검증한다. 이것은 민첩함을 가져오는 consumer-driven 접촉 도움이고, 소비자는 공급자로부터 무엇을 기대하는지 접촉하여 말할 것이다.

 

# - 결론

Microservices 아키텍쳐 스타일은 잘 알려진 이점을 가지고 있고, 명확하게 비즈니스 참여를 빠르게 하도록 도움을 줄 것이다. 하지만, 단일화된 서비스는 잘 수행되어 왔고, 계속적으로 몇 년간 될 것이다. Microservices의 운영적인 요구사항을 고려와 단일화된 서비스에서 Microservices로 리팩토링하기 전에 추가적인 이점을 고려하라. 오랫동안, 더 나은 소프트웨어 엔지니어, 조직적인 문화, 아키텍쳐는 단일화된 서비스를 좀 더 agile을 가능하게 할 것이다. 하지만, Microservices 길을 따르고 싶다고 결정하였다면, 이것은 시작하는데 도움이 될 것이다.

 

 

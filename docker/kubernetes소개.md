# 쿠버네티스

## 소개

- 쿠버네티스 : 중앙화된 어플리케이션의 배포를 오케스트레이터를 위한 오픈 소스

- Google이 만듦
- 개발자들은 신뢰성있게 여러 시스템에 배포할 수 있고, 머신러닝, 빅데이터, 배치 워크로드도 실행이 가능하다.
- 쿠버네티스 클러스트들은 오케스트레이션 API를 제공해서 개발자들이 정의하고, 정의된 구조로 어플리케이션을 배포할 수 있음.
- 쿠버네티스 클러스터 수많은 온라인으로 장애가 있을때 본인 스스로 복구가 가능한 알고리즘을 가지고 있다.
- 쿠버네티스는 다운 타임이 없는(zero-downtime) 업데이트, 레플리카를 포함해서 엄청나게 많은 트래픽을 분산시킬 수 있는  API를 제공한다.
- 쿠버네티스는 MSA에서 서비스를 네이밍(naming)하고 디스커버(discover)하 수 있는 툴을 제공한다.



## 클러스터 운영에서 중요한 부분

- 쿠버네티스의 구조 및 원리에 대해서 이해하는 것이 매우 중요
- End-user를 위한 클러스터는 무엇인가? 클러스터 삭제에서 복잡하고 어려운 부분은 무엇인가?

## 컨테이너

컨테이너는 2가지로 구성되어 있다.

1. 컨테이너 이미지
   1. 컨테이너 이미지는 컨테이너를 구동하기 위한 바이너리파일, 라이브러리, 데이터 등을 가지고 있다.
   2. 개발자들은 어플리케이션을  packing 할 수 있고, 다른 다양한 환경에서도  똑같이 배포를 할 수 있다.
2.   실행중인 프로세스를 분리하는 일련의 운영 체제 개념 
   1. **컨테이너 이미지가 구동될 때,  OS 에서  네임스페이스(namespace)를 사용해서 실행** 할 수 있다. 네임스페이스 프로세스를 포함하고, 격리된(isolated) 프로세스를 제공한다. **격리(isolation)** 의 의미는 예를 들면, 각각의 컨테이너는 각각의 파일시스템을 가지고 있는 것이다.(chroot 처럼) 
   2. 각각의 컨테이너는 **네트워크**를 가지고 있으며 PID 네이스페이스를 가지고 있다. 이것의 의미는 하나의 컨테이너에서 프로세스 42번은 다른 컨테이너에서 프로세스 42번과 다르다는 의미이다. 커널에서 다른 여러가지 네임스페이스가 있고, 이것은 여러개의 컨테이너를 각각 돌릴 수 있게한다. control group(cgroups)는 CPU나 메모리 같이 리소스의 사용의 격리를 할 수 있게 한다. SELinux, AppArmor와 같은 표준 OS같은 컨테이너에서 사용할 수 있다. 결론적으로, 이러한 격리는 각각의 컨테이너들끼리 인터페이스 하는데 복잡하게 한다.

* docker에서의 도구는 Dokerfile로 관리하며, 컨테이너 이미지를 어떻게 만드는지 정의를 한다. (참고할만한 책 :  Docker: Up and Running (O’Reilly) 
* 도커 이미지를 생성하면, 다른 환경(다른 사람 컴퓨터, cloud, IDC 등)에 배포를 할 방법을 찾아야한다. 이때 하는 과정이 이미지 등록이다. 이미지를 만든 후, 이미지 등록을 한다.(push) 이미지 등록 후에, pull, download 할 수 있다.



## Container Orchestration

컨테이너 이미지를 어딘가에 저장을 한다면, 어플리케이션을 구동시켜야한다. 여기에서 필요한 것이 Kubernetes와 같은 컨테이너 오케스트레이션이다. 쿠버네티스에서의 잡(job)은 CPU, memory, disk 등의 기계(서버) 그룹을 가지고 있고, 각각의 컨테이너에 배포하는 컨테이너화된 API로 변환한다.

Kubernetes의 API는 원하는대로 만들 수 잇는데, 예를 들면 "이 컨테이너 이미지를 가지고 구동하고 싶고, 사양은 3개의 core와10기가바이트의 메모리를 사용하고 싶습니다" 쿠버네티스 시스템은 서버의 상태를 확인하고 컨테이너가 동작할 좋은 위치를 찾아내고, 동작할 시점을 스케쥴링한다. 개발자들은 컨테이너 이미지가 동작하는 것을 보고, 어느 특정 컨테이너에 동작을 해야하는지 고민할 필요는 없다. 또한, "3개의 컨테이너 이미지의 복제본을 다른 서버에 동작하게 하고 싶고, 각가은 3개의 코어에 10기가바이트의 메모리로 해주세요" 라는 것을 쿠버네티스 API를 사용해서 쉽게 할 수 있다. 오케스트레이션이란 서버에서의 컨테이너 스케쥴링 이상의 기능을 한다. 예를 들면, 쿠버네티스 오케스트레이터는 실패 했을시 어떻게 복구를 하는지 알 수 있다. 컨테이너에서 프로세스가 충돌하면, 쿠버네티스는 재실행한다. 만약에 health check를 정의한다면, 쿠버네티스는 어플리케이션이 deadlock에 걸렸는지 아니면 재 시작을 해야하는지(liveness check) 헬스체크를 할 수 있고, 로드밸런스 서비스도 할 수 있다. (readiness checks) 쿠버네티스 API는 여러개의 레플리카 셋에서 트래픽을 로드 밸런싱하는 것도 목표이긴 한다. 예를 들면, "지금 동작하는 컨테이너에서 로드 벨러서를 만들어주세요" 이러한 로드 벨런서는 쉽게 발견할 수 있는 이름을 가지고 있어서, 다른 서비스와 함께 클러스터링한는 것이 매우 쉽다.



## Kubernetes API

Kubernetes API는 Restful API 기반이다.

### 핵심 개념 : Pods, ReplicaSets, and Servies

#### Pods

Pods이란 쿠버네티스 클러스터에서 가장 작은 단위의 스케쥴링이다. Pod은 1개 이상의 컬렉션으로 되어 있으며, 동작하는 이미지를 가지고 있다. Pod이 가장 작은 단위(atomic)라는 의미는 클러스터 내에서 가은 서버에서 동일한 동작(land)을 보장한다는 것이다. Pods은 여러개의 컨테이너들간의 많은 리소스를 공유한다. 예를 들면, pods끼리 같은 네트워크 내에서 namespace를 공유하는데, pods 내의 각각의 컨테이너는 다른 컨테이너에서 localhost로 바라본다는 것이다. Pods끼리는 프로세스, interprocess communication namespace를 공유하고 있고, 다른 컨테이너는 pod 내에서 공유되는 메로리, signaling, coordinate를 할 수 있다는 것이다. 이러한 가까운 그룹은, Pods은 컨테이너들끼리 상징적인 관계를 가지고 있는데, 예를 들면 메인으로 동작하는 컨테이너와 백그라운드 데이터를 로딩하는 컨테이너이다. 컨테이너 이미지를 분리하는 것은 애자일 팀에서 컨테이너 이미지를 각자의 이미지로 재사용하고, 운영할때는 동일한 이미지를 쓸 수 있다. Pods은 스케일링하고 복제하는 단위이다. Pods에서 헬스체크를 정의하면, Pods이 자동적으로 재시작할 수 있다.



#### ReplicaSets

컨테이너 오케스트레이션의 가장 큰 이유 중 하나는 복제하기 쉽고, 신뢰성있는 시스템을 만들기 위해서이다. 각각의 커네티너가 실패하거나 시스템의 부하를 견디지 못할때, 어플리케이션 복제본은 서비스가 완전히 장애를 맞을가능성을 줄여준다. 쿠버네티스 API에서, 이러한 stateless replication은 ReplicaSet이라는 객체로 처리된다. ReplicaSets는  Pod에서 정의된 여러개의 복제본을 가질 수 있다. Replication은 Kubernetes controller manager로 의해서 처리되고, Kubernetes controller manager는 쿠버네티스 스케쥴러에 의해서 Pods를 생성한다.



#### Services


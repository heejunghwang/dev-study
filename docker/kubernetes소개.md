# 쿠버네티스

## 소개

- 쿠버네티스 : 중앙화된 어플리케이션의 배포를 오케스트레이터를 위한 오픈 소스

- Google이 만듦
- 개발자들은 신뢰성있게 여러 시스템에 배포할 수 있고, 머신러닝, 빅데이터, 배치 워크로드도 실행이 가능하다.
- 쿠버네티스 클러스트들은 오케스트레이션 API를 제공해서 개발자들이 정의하고, 정의된 구조로 어플리케이션을 배포할 수 있음.
- 쿠버네티스 클러스터 수많은 온라인으로 장애가 있을때 본인 스스로 복구가 가능한 알고리즘을 가지고 있다.
- 쿠버네티스는 다운 타임이 없는(zero-downtime) 업데이트, 레플리카를 포함해서 엄청나게 많은 트래픽을 분산시킬 수 있는  API를 제공한다.
- 쿠버네티스는 MSA에서 서비스를 네이밍(naming)하고 디스커버(discover)하 수 있는 툴을 제공한다.



## 클러스터 운영에서 중요한 부분

- 쿠버네티스의 구조 및 원리에 대해서 이해하는 것이 매우 중요
- End-user를 위한 클러스터는 무엇인가? 클러스터 삭제에서 복잡하고 어려운 부분은 무엇인가?

## 컨테이너

컨테이너는 2가지로 구성되어 있다.

1. 컨테이너 이미지
   1. 컨테이너 이미지는 컨테이너를 구동하기 위한 바이너리파일, 라이브러리, 데이터 등을 가지고 있다.
   2. 개발자들은 어플리케이션을  packing 할 수 있고, 다른 다양한 환경에서도  똑같이 배포를 할 수 있다.
2.   실행중인 프로세스를 분리하는 일련의 운영 체제 개념 
   1. **컨테이너 이미지가 구동될 때,  OS 에서  네임스페이스(namespace)를 사용해서 실행** 할 수 있다. 네임스페이스 프로세스를 포함하고, 격리된(isolated) 프로세스를 제공한다. **격리(isolation)** 의 의미는 예를 들면, 각각의 컨테이너는 각각의 파일시스템을 가지고 있는 것이다.(chroot 처럼) 
   2. 각각의 컨테이너는 **네트워크**를 가지고 있으며 PID 네이스페이스를 가지고 있다. 이것의 의미는 하나의 컨테이너에서 프로세스 42번은 다른 컨테이너에서 프로세스 42번과 다르다는 의미이다. 커널에서 다른 여러가지 네임스페이스가 있고, 이것은 여러개의 컨테이너를 각각 돌릴 수 있게한다. control group(cgroups)는 CPU나 메모리 같이 리소스의 사용의 격리를 할 수 있게 한다. SELinux, AppArmor와 같은 표준 OS같은 컨테이너에서 사용할 수 있다. 결론적으로, 이러한 격리는 각각의 컨테이너들끼리 인터페이스 하는데 복잡하게 한다.

* docker에서의 도구는 Dokerfile로 관리하며, 컨테이너 이미지를 어떻게 만드는지 정의를 한다. (참고할만한 책 :  Docker: Up and Running (O’Reilly) 
* 도커 이미지를 생성하면, 다른 환경(다른 사람 컴퓨터, cloud, IDC 등)에 배포를 할 방법을 찾아야한다. 이때 하는 과정이 이미지 등록이다. 이미지를 만든 후, 이미지 등록을 한다.(push) 이미지 등록 후에, pull, download 할 수 있다.



## Container Orchestration

컨테이너 이미지를 어딘가에 저장을 한다면, 어플리케이션을 구동시켜야한다. 여기에서 필요한 것이 Kubernetes와 같은 컨테이너 오케스트레이션이다. 쿠버네티스에서의 잡(job)은 CPU, memory, disk 등의 기계(서버) 그룹을 가지고 있고, 각각의 컨테이너에 배포하는 컨테이너화된 API로 변환한다.

Kubernetes의 API는 원하는대로 만들 수 잇는데, 예를 들면 "이 컨테이너 이미지를 가지고 구동하고 싶고, 사양은 3개의 core와10기가바이트의 메모리를 사용하고 싶습니다" 쿠버네티스 시스템은 서버의 상태를 확인하고 컨테이너가 동작할 좋은 위치를 찾아내고, 동작할 시점을 스케쥴링한다. 개발자들은 컨테이너 이미지가 동작하는 것을 보고, 어느 특정 컨테이너에 동작을 해야하는지 고민할 필요는 없다. 또한, "3개의 컨테이너 이미지의 복제본을 다른 서버에 동작하게 하고 싶고, 각가은 3개의 코어에 10기가바이트의 메모리로 해주세요" 라는 것을 쿠버네티스 API를 사용해서 쉽게 할 수 있다. 오케스트레이션이란 서버에서의 컨테이너 스케쥴링 이상의 기능을 한다. 예를 들면, 쿠버네티스 오케스트레이터는 실패 했을시 어떻게 복구를 하는지 알 수 있다. 컨테이너에서 프로세스가 충돌하면, 쿠버네티스는 재실행한다. 만약에 health check를 정의한다면, 쿠버네티스는 어플리케이션이 deadlock에 걸렸는지 아니면 재 시작을 해야하는지(liveness check) 헬스체크를 할 수 있고, 로드밸런스 서비스도 할 수 있다. (readiness checks) 쿠버네티스 API는 여러개의 레플리카 셋에서 트래픽을 로드 밸런싱하는 것도 목표이긴 한다. 예를 들면, "지금 동작하는 컨테이너에서 로드 벨러서를 만들어주세요" 이러한 로드 벨런서는 쉽게 발견할 수 있는 이름을 가지고 있어서, 다른 서비스와 함께 클러스터링한는 것이 매우 쉽다.



## Kubernetes API

Kubernetes API는 Restful API 기반이다.

### 핵심 개념 : Pods, ReplicaSets, and Servies

#### Pods

Pods이란 쿠버네티스 클러스터에서 가장 작은 단위의 스케쥴링이다. Pod은 1개 이상의 컬렉션으로 되어 있으며, 동작하는 이미지를 가지고 있다. Pod이 가장 작은 단위(atomic)라는 의미는 클러스터 내에서 가은 서버에서 동일한 동작(land)을 보장한다는 것이다. Pods은 여러개의 컨테이너들간의 많은 리소스를 공유한다. 예를 들면, pods끼리 같은 네트워크 내에서 namespace를 공유하는데, pods 내의 각각의 컨테이너는 다른 컨테이너에서 localhost로 바라본다는 것이다. Pods끼리는 프로세스, interprocess communication namespace를 공유하고 있고, 다른 컨테이너는 pod 내에서 공유되는 메로리, signaling, coordinate를 할 수 있다는 것이다. 이러한 가까운 그룹은, Pods은 컨테이너들끼리 상징적인 관계를 가지고 있는데, 예를 들면 메인으로 동작하는 컨테이너와 백그라운드 데이터를 로딩하는 컨테이너이다. 컨테이너 이미지를 분리하는 것은 애자일 팀에서 컨테이너 이미지를 각자의 이미지로 재사용하고, 운영할때는 동일한 이미지를 쓸 수 있다. Pods은 스케일링하고 복제하는 단위이다. Pods에서 헬스체크를 정의하면, Pods이 자동적으로 재시작할 수 있다.



#### ReplicaSets

컨테이너 오케스트레이션의 가장 큰 이유 중 하나는 복제하기 쉽고, 신뢰성있는 시스템을 만들기 위해서이다. 각각의 커네티너가 실패하거나 시스템의 부하를 견디지 못할때, 어플리케이션 복제본은 서비스가 완전히 장애를 맞을가능성을 줄여준다. 쿠버네티스 API에서, 이러한 stateless replication은 ReplicaSet이라는 객체로 처리된다. ReplicaSets는  Pod에서 정의된 여러개의 복제본을 가질 수 있다. Replication은 Kubernetes controller manager로 의해서 처리되고, Kubernetes controller manager는 쿠버네티스 스케쥴러에 의해서 Pods를 생성한다.



#### Services
replicaset을 만든다음에, 여러개의 다른 레플리카로 트래픽을 분산 처리하기 위한 로드밸런서를 생성해야한다. 이것을 위해서, Service 객체를 가지고 있다. Service는 TCP또는 UDP 로드밸런스 서비스를 의미한다. Service가 생성되면, 다음과 같은 3가지를 가지고 있다.
- IP 주소
- 쿠버네티스 클러스터 DNS에서의 DNS entry
- 로드밸런싱 규칙, (Pods을 위한 트래픽의 프록시)

서비스가 만들어질 때, 고정 IP로 할당되고, 이 IP는 가상이므로 네트워크에서 보이는 어떠한 인터페이스에 응답하지 않는다. 
대신에 그것은 로드 밸런싱 된 IP 주소로 네트워크망에 그람을 그렸습니다. 
대신,로드 밸런싱 된 IP 주소로 네트워크망에 프로그래밍됩니다. 패킷이 해당 IP로 전송되면 서비스를 구현하는 포드 세트로 로드 밸런싱됩니다. 수행되는 로드 밸런싱은 소스 및 대상 IP 주소 튜플에 따라 라운드 로빈이거나 결정적 일 수 있습니다.

이 고정 IP가 있으면, DNS이름은 쿠버네티스 클러스터의 DNS서버에서의 DNS이름으로 프로그래밍된다. DNS 주소는 semantic name(예: fronted)로 제공된다.  Kubernetes Service 객체의 이름과 동일하며 클러스터의 다른 컨테이너가 서비스로드 밸런서의 IP 주소를 발견 할 수 있도록합니다. 이 네트워크 패브릭 프로그래밍은 동적이므로 Pod가 실패하거나 ReplicaSet의 스케일링으로 인해 이동함에 따라로드 밸런서는 클러스터의 현재 상태와 일치하도록 지속적으로 다시 프로그래밍됩니다. 이는 클라이언트가 항상 서비스를 구현하는 포드로 해석되는 서비스 IP 주소에 대한 연결에 의존 할 수 있음을 의미합니다.

### Storage: Persistent Volumes, ConfigMaps, and Secrets

Kubernetes에 도입 된 첫 번째 스토리지 개념은 실제로 Pod API의 일부인 Volume이었습니다. 포드 내에서 볼륨 세트를 정의 할 수 있습니다. 각 볼륨은 다양한 유형 중 하나 일 수 있습니다. 현재 NFS, iSCSI, gitRepo, 클라우드 스토리지 기반 볼륨 등 10 가지 이상의 다양한 볼륨을 생성 할 수 있습니다. 포드에 볼륨을 추가 할 때 각 실행 컨테이너의 임의 위치에 볼륨을 마운트하도록 선택할 수 있습니다. 이를 통해 실행중인 컨테이너가 볼륨 내의 스토리지에 액세스 할 수 있습니다. 다른 컨테이너는 이러한 볼륨을 다른 위치에 마운트하거나 볼륨을 완전히 무시할 수 있습니다.

기본 파일 외에도 포드에 볼륨으로 마운트 할 수있는 몇 가지 유형의 Kubernetes 객체가 있습니다. 이들 중 첫 번째는 ConfigMap 객체입니다. ConfigMap은 구성 파일 모음을 나타냅니다. 쿠 버네 티스에서는
동일한 컨테이너 이미지에 대해 다른 구성을 원합니다. ConfigMap 기반 볼륨을 포드에 추가하면 ConfigMap의 파일이 실행중인 컨테이너의 지정된 디렉토리에 표시됩니다.

Kubernetes는 데이터베이스 암호 및 인증서와 같은 보안 데이터에 비밀 구성 유형을 사용합니다. 볼륨과 관련하여 Secret은 ConfigMap과 동일하게 작동합니다. 볼륨을 통해 포드에 연결하고 사용중인 컨테이너에 장착 할 수 있습니다.

시간이 지남에 따라 볼륨을 사용하여 애플리케이션을 배포하면 볼륨을 포드에 단단히 바인딩하는 것이 실제로 문제가되는 것으로 나타났습니다. 예를 들어, ReplicaSet을 통해 복제 된 컨테이너를 만들 때는 모든 복제본에서 동일한 정확한 볼륨을 사용해야합니다.

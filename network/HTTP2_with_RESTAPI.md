# HTTP/2와 함께 사용하는 REST API 장점

## HTTP/1.x vs HTTP/2
상위 단계에서의 차이점을 살펴보겠습니다.

### HTTP/2 는 텍스트가 대신 Binary
Binary 프로토콜은 파싱할 때 더 효율적이고, 압축적입니다. 가장 중요한 것은, HTTP/1.x와 같은 텍스트 기반 프로토콜과 비교했을때, 오류가 적습니다. 왜냐하면, 공백(whitespace) 대문자화하거나, 줄 끝남, 공백 줄 등과 같은 것을 처리하는데 더 여유가 있기 때문입니다.
예를 들면, HTTP/1.1 에서는 메시지를 파싱하는데 네가지를 정의하였습니다. 하지만, HTTP/2에서는, 단 하나의 코드 방법이 있습니다.

### HTTP/2는 완벽하게 복합적입니다. (순서적이지 않습니다.)
HTTP/1.x 에서는 "head-of-line blocking" 이라는 문제점이 있었습니다. 이것은, 하나의 요청은 하나의 한번에 할 수 있는 것입니다.

HTTP/1.1d에서는 이러한 과정을 고치기 위해서 노력하였지만, 완벽하게 문제를 해결할 수 없었습니다.(크거나 너무 느린 응답은 다른 요청을 여전히 막았습니다) 게다가, 이러한 과정은 배포하는데 매우 문제가 있었습니다. 왜냐하면, 많은 웹 매개체(intermediaries)와 서버들은 올바르게 수행되지 못했기 때문입니다.

(그림)

이것은 클라이언트에게 어떠한 출처에서부터 연결을 요청을 해야하는지 많은 결정을 하도록 하였습니다. 그리고, 대부분 1페이지에서 로드하기 위해서 10번이나 혹은 더 많이 연결을 해야했는데, 성능에 아주 큰 영향이 있었고, 요청의 폭포수("waterfall") 차단 현상이 일어났습니다.

복합적인것은 빠르게 여러개의 요청을 하고, 메시지를 응답할 때 문제가 되었습니다. 이것은 심지어, 다른것과 함께 메시지를 섞을 수도 있는 가능성이 있었습니다.

따라서, 클라이언트는 한 페이지를 로드할 때 하나의 출처에서 하나의 요청만 했었어야 합니다.

## HTTP/2는 동시에 하나의 연결을 사용할 수 있습니다.
HTTP/1에서는, 브라우저는 4개에서 8개의 연결을 열었습니다. 왜냐하면, 많은 사이트들은 여러 출처를 사용하고 있었고, 하나의 페이지를 로드하는데 30번이상 연결을 하도록 해야했습니다.

하나의 어플리케이션에서 여러개의 연결을 한다는 것은, TCP 기반에서 동시성을 깨뜨릴 수 있습니다. 왜냐하면, 여러개의 연결은 응답에서 요청의 홍수를 시작시킬 수 있고, 네트워크의 사이에서의 버퍼를 초과하는 위험요소가 있어서 이벤트를 혼잡하게 하거나 제한을 만들 수 있습니다.

~~~
여기에서 HTTP/2 가 어떻게 되는지 볼 수 있습니다.
https://http2.akamai.com/demo
~~~

게다가, 많은 연결은 네트워크의 리소스를 불공평하게 독점할 수 있습니다. 어플리케이션의 행동을 더 좋게 하기 위해서, 다른것에서 "훔치는" 행동을 합니다.(예를 들면, VoIP)

### HTTP/2는 부하를 줄이기 위해서 헤더의 압축을 사용합니다.
만약에 한페이지에서 80개의 리소스를 가지고 있다고 가정하고, 각각의 요청은 헤더에 1400 바이트를 가지고 있다면, 헤더를 얻기 위해서 7~8번정도 통신을 해야할 것입니다. 이것은 응답 시간이 아니라, 클라이언트에서 나가기 위한 것입니다.

(그림)

이것은 TCP는 느린 시작 메커니즘을 가지고 있기 때문에, 얼마나 많은 패킷이 인식되었느냐에 따라서 패킷을 새로운 연결로 보냅니다. 이것은, 패킷의 수를 효과적으로 제한하고, 첫번째에서 몇번의 요청만 보내지면 됩니다.

하지만, 패킷이라고 가정했을때도, 헤더에 약한 압축은 이러한 요청들은 한번에 요청을 보내도록 합니다. 

이러한, 모바일 클라이언트에 영향이라고 가정했을때도, 오버헤드를 고려했을 때, 안좋은 조건이라도 몇번의 100 ms의 왕복 요청을 볼 수 있습니다.


### HTTP/2에서는 ㅡ서버에게 클라이언트 캐시(Caches)에게 "Push" 응답합니다.
한 페이지에서 브라우저가 요청했을때, 서버는 응답으로 HTML를 보내고, 브라우저가 HTML을 파싱하도록 기다려야 하는데, Javascript나 이미지, CSS를 보내기 시작하기 전에 리소스들이 붙여질 수 있는 요청 이슈가 있습니다.

Server Push는 서버에게 "pushing" 응답을 하며 연기되는 왕복 여정을 피하게 하는 가능성을 주고, 클라이언트는 cache가 필요하다고 생각할 것입니다.

그러나, pushing 응답은 "마법"은 아닙니다. 잘못하용하면, 성능에 영향을 줄 수 있습니다. 지금부터, Webhooks와 함께 게속 할 수 잇는 방법을 보겠습니다.

## HTTP / 1.1 기반의 기존 REST API에 어떻게 영향을 줍니까?


HTTP의 주요 의미는 HTTP/2에서 유지되었습니다. 이것은, HTTP 메소드에서  GET, POST, HTTP headers, URI들을 가지고 있다는 것을 의미합니다.

HTTP/1.1 관점에서 봤을때 HTTP/2의 변경은 HTTP 의미입니다. (예: " PUT으로 요청시 host는 domain.com에 /foo 디렉토리에서의 자원(resource)를 원합니다") 이 의미는 인터넷 선(wire)으로 보내졌습니다. 이것은, HTTP/1.1에서 만들어진 REST API는 계속 예전처럼 작동할 것이고, 어플리케이션에 변화는 없을 것입니다.

응용 프로그램을 실행하는 웹 컨테이너는 응용 프로그램을 대신하여 새로운 인터넷 선(wire)에서 일반적인 HTTP 의미로 변환될것입니다. 어플리케이션은 오직 상위 수준의 HTTP 의미만 볼것입니다. 인터넷 선(wire)에서 HTTP/1.1이던, HTTP/2이던지 상관없이요.

왜나하면, HTTP/2의 인터넷 선(wire) 형식은 더 효율적입니다(특히, 다중화와 압축에서) HTTP/2에서의 REST API는 이것이 더 좋을 것입니다.

HTTP / 2, HTTP / 2 Push의 다른 주요 개선점은 상관 관계가있는 리소스를 효율적으로 다운로드하는 것을 목표로하며, 대부분의 REST API 사용 사례에서는 유용하지 않기 때문에 서비스와 같은 Object Storage만이 이익을 얻을 수 있습니다 Amazon S3).

HTTP / 2의 일반적인 요구 사항은 TLS를 통해 배포됩니다. 이를 위해서는 배포자가 HTTP에서 HTTPS로 이동해야합니다. 즉, 신뢰할 수있는 기관 등에서 SSL 인증서를 구입해야합니다.


## HTTP/2 장점

HTTP / 2가 가져온 핵심 개선 사항에는 멀티 플렉스 된 스트림, 헤더 압축, 서버 푸시 및 텍스트 형식 대신 바이너리 프로토콜이 있습니다. 이러한 긍정적인 변화로 인해 많은 추가 파일이 첨부 된 웹 페이지 (예 : 스타일, 스크립트, 이미지, 글꼴 등)를 비롯하여 좋은 웹 페이지로드 결과를 얻을 수 있었습니다.


(그림)

HTTP 프로토콜의 새 버전 인 HTTP / 2는 서버 간 통신을위한 많은 새로운 기능을 제공합니다.

### 푸시 요청을 사용하는 양방향 통신

HTTP / 2의 "서버 푸시 (server push)"기능을 통해 서버는 향후 사용을 위해 사전에 클라이언트의 캐시로 보낼 수 있습니다. 이렇게하면 HTML과 링크 된 스타일 시트 및 CSS를 가져 오는 것과 같은 왕복을 피할 수 있습니다. 서버는 클라이언트가 요청하기를 기다리지 않고 바로 이러한 작업을 시작할 수 있습니다.

또한 사람들의 요청에 따라 클라이언트 캐시를 사전에 업데이트하거나 무효화하는 데 유용합니다.

물론 어떤 상황에서는 클라이언트가 푸시 된 항목을 원하지 않습니다. 일반적으로 이미 사본이 있거나 사용하지 않는다는 것을 알고 있기 때문입니다. 이 경우 RST_STREAM을 사용하면 "아니오"라고 할 수 있습니다.

### 단일 TCP 연결 내 멀티플렉싱
HTTP / 2는 멀티플렉싱을 사용하여 많은 메시지가 동시에 연결에 인터리빙되도록하여 하나의 큰 응답 (또는 서버가 생각하는 데 오랜 시간이 걸리는 메시지)이 다른 메시지를 차단하지 못하도록합니다.

또한 헤더 압축을 추가하여 요청한 항목이 매우 적더라도 정상적인 요청 및 응답 헤더가 대역폭을 압도하지 않도록합니다. 큰 요청 헤더를 가져 오면 많은 왕복 이동으로 많은 리소스가있는 페이지로드 시간을 쉽게 날려 버릴 수있는 모바일에서의 큰 승리입니다.

### 장기 실행 연결

HTTP / 2는 적은 수의 연결을 사용하도록 설계되었으므로 서버와 네트워크의 부하가 적습니다. 이것은 HTTP / 1이 병렬 연결을 위해 다중 연결을 사용하여 문제가 추가되기 때문에 네트워크가 혼잡해질 때 특히 중요합니다.

예를 들어 휴대 전화가 각 서버에 6 개의 TCP 연결을 열어 페이지 리소스를 다운로드하는 경우 (요즘 대부분의 페이지가 여러 서버를 사용한다는 것을 기억하면) 모바일 네트워크의 버퍼가 너무 쉽게 과부하되어 패킷을 삭제하고 재전송을 트리거하며, 문제를 더욱 악화시킵니다.

HTTP / 2를 사용하면 호스트 당 하나의 연결을 사용할 수 있으며 가능하면 사이트에서 한 호스트에 콘텐츠를 통합 할 것을 권장합니다.

### 상태 유지 연결
HTTP / 1 클라이언트가 요청을 보낸 다음 응답이 필요 없다는 것을 알게되면 대역폭을 절약하려면 연결을 닫아야합니다. 그것을 복구 할 안전한 방법은 없습니다.

HTTP / 2는 클라이언트가 마음을 바꿀 수 있도록 RST_STREAM 프레임을 추가합니다. 브라우저가 페이지에서 벗어나거나 사용자가 다운로드를 취소하면 해당 대역폭을 모두 낭비하지 않고 새 연결을 열지 않아도됩니다.

다시 말하지만, 이것은 인식 된 성능과 네트워크 친숙 함을 개선하는 것입니다. 이 일반적인 시나리오에서 클라이언트가 연결을 유지할 수있게함으로써 추가 왕복 및 리소스 소비가 방지됩니다.

## HTTP/2 단점

### 텍스트 대신 Binary 사용
좋기도 하지만, 좋지 않은 기능이기도 합니다.

HTTP / 1에 대한 좋은 점 중 하나는 텔넷을 열어 요청을 입력하고 (서버가 시간 초과되지 않으면) 응답을 보는 것입니다. 바이너리 프로토콜이므로 HTTP / 2에서는 실용적이지 않습니다. 

예를 들어, 우리가 short int 30000 (0x7530)을 텍스트와 바이너리로 저장할 수있는 방법을 생각해보십시오 :

(그림)

보시다시피, 5 바이트를 사용하는 대신 2 바이트를 사용합니다. 그것은 50 % 이상의 크기 축소입니다.

바이너리 프로토콜은 분석 할 오버 헤드가 낮고 네트워크 설치 공간이 약간 가벼울뿐 아니라 바이너리 프로토콜이 더 간단하기 때문에 오류가 발생하기 쉽습니다.

텍스트 프로토콜은 문자열을 구분하는 방법 (이중 줄 바꿈이라고 계산), 공백을 처리하는 방법, 추가 문자 등과 같은 문제를 다루어야하기 때문입니다. 이는 많은 구현 복잡성을 초래합니다. HTTP / 1에서는 메시지가 언제 끝나는지를 알려주는 세 가지 방법과 복잡한 방법을 사용하여 어떤 방법이 사용 중인지를 결정합니다.

HTTP / 1의 본질은 많은 보안 문제의 근원이기도합니다. 구현마다 메시지를 구문 분석하는 방법에 대해 다른 결정을 내리기 때문에 악의적 인 당사자가 (예 : 응답 분할 공격과 함께) 자신의 방식을 바꿀 수 있습니다.

텍스트에서 벗어나는 또 다른 이유는 HTTP / 1과 같이 원격으로 보이는 모든 것이 HTTP / 1로 처리되므로 멀티플렉싱과 같은 기본적인 기능을 추가 할 때 (잘못된 메시지의 내용을 연결하면 심각한 결과가 발생할 수 있음) 완전히 중단해야합니다.

물론이 모든 것은 프로토콜을 디버깅하기를 원하는 ops를 잘 못하는 사람들을 위한 작은 위안입니다. 즉, 우리는이 단점을 해결하기 위해 새로운 도구와 충분한 도구가 필요할 것입니다. 시작하려면 Wireshark에 이미 플러그인이 있습니다.

### More Encryption

HTTP / 2는 TLS (웹의 암호화 레이어 인 SSL 표준 양식)를 사용할 것을 요구하지 않지만 사이트의 빠른 속도에 미치는 영향을 줄이므로 암호화를 사용하면 성능이 향상됩니다. 즉, SSL 인증서를 구입하고 갱신해야 할 필요가있을 것입니다. REST API를 사용하여 여러 마이크로 서비스로 작업 할 때 지출하는 금액은 적지 않습니다.

실제로 많은 사람들은 "개방형"인터넷에 새로운 프로토콜을 배포하는 유일한 안전한 방법은 암호화를 사용하는 것이라고 믿습니다. Firefox와 Chrome은 TLS를 사용하여 HTTP / 2 만 지원할 것이라고 말했습니다.

그들에게는 이것에 대한 두 가지 이유가 있습니다. 하나는 인터넷을 통해 새로운 버전의 HTTP를 배포하는 것이 어렵다는 것입니다. 프록시 및 방화벽과 같은 많은 "미들 박스"는 HTTP / 1이 변경되지 않는다고 가정하고 상호 운용성 및 보안 문제를 도입 할 수 있다고 가정하기 때문에 HTTP / 2 연결을 해석하십시오.


다른 하나는 웹이 점점 더 위험한 곳이며 많은 암호화를 사용하는 것이 여러 가지 위협을 완화하는 한 가지 방법이라는 것입니다. HTTP / 2를 TLS를 사용하는 사이트의 당근으로 사용함으로써 그들은 웹의 전반적인 보안이 향상되기를 바라고 있습니다.

# 요약
기존 REST API의 실질적인 이점은 REST 기반의 대부분의 마이크로 서비스가 서버 간 통신을 수행하는 경우입니다. 오늘날의 마이크로 서비스 아키텍처에서는 많은 마이크로 서비스가 다양한 방식으로 상호 작용하지만 REST를 사용하는 경우 HTTP / 2가 워크 플로의 속도를 높일 수 있습니다.

HTTP / 2는 JavaScript API를 정의하지 않으며 REST API를 훨씬 쉽게 빌드하는 데 도움이되지 않습니다. 현재 웹 브라우저에서 실행중인 JavaScript 클라이언트는 새로운 기능을 제한적으로 사용할 수 있습니다. 그러나 서버 간 통신의 경우 HTTP / 2는 기존 REST API를 능가하는 많은 방법을 제공합니다.

게다가, HTTP / 2의 네트워크 친숙성의 단점은 TCP 혼잡 제어를 더욱 두드러지게 만든다는 점입니다. 이제 브라우저는 호스트 당 하나의 연결 만 사용하므로 초기 창과 패킷 손실이 훨씬 더 분명합니다.

HTTP가 정밀 조사, 실험 및 진화의 시대를 거치 자마자 커뮤니티의 관심이 TCP 및 성능에 미치는 영향으로 변하고 있음이 분명 해지고 있습니다. 이미 IETF에서 TCP를 수정하고 심지어 바꾸는 것에 대한 초기 논의가있었습니다.



# 출처
https://dzone.com/articles/benefits-of-rest-apis-with-http2?utm_source=Top%205&utm_medium=email&utm_campaign=Top%205%202018-01-123

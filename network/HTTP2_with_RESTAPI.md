# HTTP/2와 함께 사용하는 REST API 장점

## HTTP/1.x vs HTTP/2
상위 단계에서의 차이점을 살펴보겠습니다.

### HTTP/2 는 텍스트가 대신 Binary
Binary 프로토콜은 파싱할 때 더 효율적이고, 압축적입니다. 가장 중요한 것은, HTTP/1.x와 같은 텍스트 기반 프로토콜과 비교했을때, 오류가 적습니다. 왜냐하면, 공백(whitespace) 대문자화하거나, 줄 끝남, 공백 줄 등과 같은 것을 처리하는데 더 여유가 있기 때문입니다.
예를 들면, HTTP/1.1 에서는 메시지를 파싱하는데 네가지를 정의하였습니다. 하지만, HTTP/2에서는, 단 하나의 코드 방법이 있습니다.

### HTTP/2는 완벽하게 복합적입니다. (순서적이지 않습니다.)
HTTP/1.x 에서는 "head-of-line blocking" 이라는 문제점이 있었습니다. 이것은, 하나의 요청은 하나의 한번에 할 수 있는 것입니다.

HTTP/1.1d에서는 이러한 과정을 고치기 위해서 노력하였지만, 완벽하게 문제를 해결할 수 없었습니다.(크거나 너무 느린 응답은 다른 요청을 여전히 막았습니다) 게다가, 이러한 과정은 배포하는데 매우 문제가 있었습니다. 왜냐하면, 많은 웹 매개체(intermediaries)와 서버들은 올바르게 수행되지 못했기 때문입니다.

(그림)

이것은 클라이언트에게 어떠한 출처에서부터 연결을 요청을 해야하는지 많은 결정을 하도록 하였습니다. 그리고, 대부분 1페이지에서 로드하기 위해서 10번이나 혹은 더 많이 연결을 해야했는데, 성능에 아주 큰 영향이 있었고, 요청의 폭포수("waterfall") 차단 현상이 일어났습니다.

복합적인것은 빠르게 여러개의 요청을 하고, 메시지를 응답할 때 문제가 되었습니다. 이것은 심지어, 다른것과 함께 메시지를 섞을 수도 있는 가능성이 있었습니다.

따라서, 클라이언트는 한 페이지를 로드할 때 하나의 출처에서 하나의 요청만 했었어야 합니다.

## HTTP/2는 동시에 하나의 연결을 사용할 수 있습니다.
HTTP/1에서는, 브라우저는 4개에서 8개의 연결을 열었습니다. 왜냐하면, 많은 사이트들은 여러 출처를 사용하고 있었고, 하나의 페이지를 로드하는데 30번이상 연결을 하도록 해야했습니다.

하나의 어플리케이션에서 여러개의 연결을 한다는 것은, TCP 기반에서 동시성을 깨뜨릴 수 있습니다. 왜냐하면, 여러개의 연결은 응답에서 요청의 홍수를 시작시킬 수 있고, 네트워크의 사이에서의 버퍼를 초과하는 위험요소가 있어서 이벤트를 혼잡하게 하거나 제한을 만들 수 있습니다.

~~~
여기에서 HTTP/2 가 어떻게 되는지 볼 수 있습니다.
https://http2.akamai.com/demo
~~~

게다가, 많은 연결은 네트워크의 리소스를 불공평하게 독점할 수 있습니다. 어플리케이션의 행동을 더 좋게 하기 위해서, 다른것에서 "훔치는" 행동을 합니다.(예를 들면, VoIP)

### HTTP/2는 부하를 줄이기 위해서 헤더의 압축을 사용합니다.
만약에 한페이지에서 80개의 리소스를 가지고 있다고 가정하고, 각각의 요청은 헤더에 1400 바이트를 가지고 있다면, 헤더를 얻기 위해서 7~8번정도 통신을 해야할 것입니다. 이것은 응답 시간이 아니라, 클라이언트에서 나가기 위한 것입니다.

(그림)

이것은 TCP는 느린 시작 메커니즘을 가지고 있기 때문에, 얼마나 많은 패킷이 인식되었느냐에 따라서 패킷을 새로운 연결로 보냅니다. 이것은, 패킷의 수를 효과적으로 제한하고, 첫번째에서 몇번의 요청만 보내지면 됩니다.

하지만, 패킷이라고 가정했을때도, 헤더에 약한 압축은 이러한 요청들은 한번에 요청을 보내도록 합니다. 

이러한, 모바일 클라이언트에 영향이라고 가정했을때도, 오버헤드를 고려했을 때, 안좋은 조건이라도 몇번의 100 ms의 왕복 요청을 볼 수 있습니다.


### HTTP/2에서는 ㅡ서버에게 클라이언트 캐시(Caches)에게 "Push" 응답합니다.
한 페이지에서 브라우저가 요청했을때, 서버는 응답으로 HTML를 보내고, 브라우저가 HTML을 파싱하도록 기다려야 하는데, Javascript나 이미지, CSS를 보내기 시작하기 전에 리소스들이 붙여질 수 있는 요청 이슈가 있습니다.

Server Push는 서버에게 "pushing" 응답을 하며 연기되는 왕복 여정을 피하게 하는 가능성을 주고, 클라이언트는 cache가 필요하다고 생각할 것입니다.

그러나, pushing 응답은 "마법"은 아닙니다. 잘못하용하면, 성능에 영향을 줄 수 있습니다. 지금부터, Webhooks와 함께 게속 할 수 잇는 방법을 보겠습니다.

## HTTP/1.1에서 존재하는 REST API 영향은?
HTTP 에서의 주유 의미는 HTTP/2에서 계속되었습니다. 이것은 GET, POST, HTTP headers, URL는 리소스르 식별하는  HTTP 방식을 가지고 있습니다.

# 출처
https://dzone.com/articles/benefits-of-rest-apis-with-http2?utm_source=Top%205&utm_medium=email&utm_campaign=Top%205%202018-01-123
